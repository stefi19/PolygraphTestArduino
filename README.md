# PolygraphTestArduino

Lightweight frontend + ESP32 sketch for viewing polygraph-like sensor data (heart, GSR, voice) over WebSocket. Includes a local simulator so you can develop and test without hardware, and an authorization + calibration workflow so plotting only begins after a 10s calibration.

This README explains what each file does and how to run the project locally (dev and production), how to test the calibration flow, and the WebSocket/HTTP protocol used by the ESP.

---

## Project overview

- Frontend: React + TypeScript (Vite) dashboard that connects to an ESP WebSocket server and shows live charts, a radial lie gauge, recording/CSV export, event log, and an authorization+calibration flow.
- ESP firmware: `connectToServer.ino` (ESP32) — reads sensor data (I2C), serves WebSocket frames on port 81, provides HTTP endpoints for simulating card detection / authorization and starting calibration.
- Local simulator: `scripts/sim_ws.js` — Node.js WebSocket server that mimics the ESP frames (includes `calibrationStarted` ack and `calibration` countdown fields) for development without hardware.

This repo is intended for local development and testing. The frontend will wait for authorization, run a 10 second calibration (either ESP-driven or frontend local fallback), then begin plotting.

---

## Where to look (important files)

- `connectToServer.ino` — ESP32 sketch
  - WebServer (HTTP) and WebSocketsServer (port 81)
  - HTTP endpoints:
    - `/card?card=ID` — simulate card detection (sets `lastCardId`)
    - `/authorize?card=ID` — manual authorize a detected card
    - `/deauthorize` — remove authorization
    - `/startCalibration?duration=N` — start an ESP-driven calibration for N seconds
  - WebSocket JSON frames include: `heart`, `gsr`, `voice`, `auth`, `leadsOff`, `lie`, `baseline`, `cardId` and `calibration` (seconds remaining)
  - Handles ESP-driven calibration accumulation and baseline establishment

- `src/EspWsDashboard.tsx` — main frontend dashboard
  - Connects to a WebSocket at `ws://<espIp>:81`
  - Persists `espIp` in localStorage
  - Waits for authorization before calibrating and plotting
  - Offers "Request ESP calibration (10s)" which sends a WS command `{ cmd: 'startCalibration', duration: 10 }`
  - Handles ack `{ calibrationStarted: N }` and periodic `calibration` field for countdown
  - Records data (Start/Stop), exports CSV, shows a radial gauge for lie probability and charts (Recharts)

- `scripts/sim_ws.js` — WebSocket simulator (Node.js, ESM)
  - Listens on `ws://localhost:81`
  - Simulates a timeline: card detected -> authorized -> baseline established
  - Handles incoming WS `{ cmd: 'startCalibration', duration: N }` and replies with `{ calibrationStarted: N }` and periodic frames containing `calibration` seconds remaining

- `package.json` — scripts & dependencies
  - `npm run dev` — start Vite dev server
  - `npm run build` — build production assets
  - `npm run preview` — preview built assets

- Optional files generated by build (committed in repo): `dist/` (production assets) — used for preview or to serve directly from the ESP if desired.

---

## WebSocket payload (what frontend receives)

Periodic JSON frames (example):

```json
{
  "heart": 520,
  "gsr": 118,
  "voice": 85,
  "auth": 1,
  "leadsOff": 0,
  "lie": 12.3,
  "baseline": 1,
  "calibration": 0,
  "cardId": "ABC123"
}
```

During calibration the ESP may include `"calibration": N` where N is seconds remaining. When the ESP receives a WS command to start calibration it will reply with the ack: `{ "calibrationStarted": 10 }`.

You can also control the ESP over HTTP endpoints listed above.

---

## WebSocket control command (from frontend to ESP)

- Start calibration (WS text message):

```js
ws.send(JSON.stringify({ cmd: 'startCalibration', duration: 10 }))
```

ESP replies (ack):
```json
{ "calibrationStarted": 10 }
```

Then periodic frames include `calibration` until it reaches 0 and `baseline` becomes 1.

---

## How the Lie probability is (currently) computed

The ESP sketch computes a simple lie probability from deviations vs a baseline (baseline collected during calibration):
- It computes relative deviations for heart, gsr (positive only), and voice vs baseline.
- It weights them and scales to a percentage. The precise weights and scaling are in `connectToServer.ino` (you may want to tune these constants and add smoothing or a z-score-based normalization for more stable results).

---

## Quick start (development)

1. Clone/pull the repo

```bash
git clone https://github.com/stefi19/PolygraphTestArduino.git
cd PolygraphTestArduino
```

2. Install node dependencies

```bash
npm ci
```

3. Start the WebSocket simulator (optional but recommended for dev without ESP)

```bash
node scripts/sim_ws.js
```

4. Start the Vite dev server (make it accessible on your LAN so you can open it on a phone):

```bash
npm run dev -- --host
```

Dev server will show a network URL (e.g. `http://192.168.1.42:5173`) — open that from your phone or laptop.

5. In the dashboard set `ESP IP` to the simulator's host (if same machine use `127.0.0.1` when testing on same device; if testing from phone set `espIp` to the dev machine LAN IP, e.g. `192.168.1.42`).

6. Connect. Flow for testing with simulator:
- Dashboard connects and shows "Waiting for authorization"\n- Click the UI button `Request ESP calibration (10s)` or the simulator will auto-advance to authorization in its timeline
- The dashboard will show the calibration countdown (driven by the ESP's `calibration` field) and an inline toast ack when calibration starts and completes
- When `baseline` becomes `1`, plotting and recording begin.

---

## Quick start (production preview)

Build and preview:

```bash
npm run build
npm run preview -- --host
```

Or serve the `dist/` directory with any static server (nginx, `python -m http.server`, `npx serve dist -s`, etc.).

---

## Running on hardware (ESP)

1. Edit `connectToServer.ino` WiFi credentials (`ssid`, `password`). Optionally set `FRONTEND_URL` to the dev server address if you want the ESP's root (/) to redirect browser clients to your Vite dev server.

2. Flash `connectToServer.ino` to your ESP32.

3. Use the ESP HTTP endpoints to simulate card/authorize if needed (useful when debugging):
- `http://<esp_ip>/card?card=ABC123` — set lastCardId
- `http://<esp_ip>/authorize?card=ABC123` — authorize
- `http://<esp_ip>/deauthorize` — deauthorize
- `http://<esp_ip>/startCalibration?duration=10` — start ESP-driven calibration

4. In the dashboard set `espIp` to the ESP IP and connect.

---

## Troubleshooting

- If your phone cannot reach the dev server, ensure you started Vite with `--host` and both devices are on the same Wi‑Fi. Also check macOS firewall settings.
- If the simulator fails to start, ensure dependencies are installed (`npm ci`) and that port 81 is free.
- If the frontend shows no data, check that your `espIp` is correct and that the WebSocket port (81) is reachable from the client.

---

## Notes & next steps (ideas)

- The current lie-probability computation is intentionally simple. Consider:
  - Normalizing features using baseline standard deviation (z-scores)
  - Applying smoothing (EMA) to `lie` before sending to the frontend
  - Calibrating weights per sensor or per-subject
- Persist recordings to IndexedDB instead of memory for longer tests
- Add authentication if exposing the ESP or simulator to public networks

---